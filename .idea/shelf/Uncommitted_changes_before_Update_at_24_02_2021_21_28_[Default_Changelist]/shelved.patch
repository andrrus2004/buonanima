Index: field_moving.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># --------------------КЛАСС С ИГРОВЫМ ПОЛЕМ--------------------\r\n\r\n\"\"\"Класс Field это класс игрового поля, а класс Object это объекты на этом игровом поле.\r\nНа то, что тут куча отдельных классов для каждого объекта можете не обращать внимание,\r\nу меня есть идея как это всё в конце убрать и оставить только класс Object\"\"\"\r\n\r\n\r\nimport pygame\r\nimport sys\r\nimport os\r\n\r\n\r\ndef load_image(name, colorkey=None):\r\n    fullname = os.path.join('assets', name)\r\n    if not os.path.isfile(fullname):\r\n        return False\r\n    image = pygame.image.load(fullname)\r\n    return image\r\n\r\n\r\n# Класс главного героя\r\nclass Hero(pygame.sprite.Sprite):\r\n\r\n    image_standart = load_image(\"hero/test_img.png\")\r\n\r\n    def __init__(self, *group):\r\n        super().__init__(*group)\r\n        self.image = Hero.image_standart\r\n        self.rect = self.image.get_rect()\r\n        self.rect.x = 0\r\n        self.rect.y = 0\r\n        # self.mask = pygame.mask.from_surface(self.image)\r\n\r\n        self.health_max = 100   # максимальное здоровье в уе\r\n        self.health_proc = 1     # здоровье в частях от целого(роцентах) от 0 до 1\r\n        self.health_current = self.health_max * self.health_proc   # здоровье в настоящем времени\r\n\r\n        self.hands = None   # предмет в руках\r\n\r\n        self.move_up = True    # можно ли пойти вверх\r\n        self.move_down = True    # можно ли пойти вниз\r\n        self.move_right = True    # можно ли пойти вправо\r\n        self.move_left = True    # можно ли пойти влево\r\n\r\n        self.step = 10    # один шаг\r\n\r\n    # -------МЕТОДЫ НАСТРОЙКИ ГЕРОЯ ПРИ ГЕНЕРАЦИИ---------\r\n\r\n    # метод смены координат(можно использовать для генерации на карте)\r\n    def set_place(self, x, y):\r\n        self.rect.x = x\r\n        self.rect.y = y\r\n\r\n    # метод для изменения информации о здоровье ГГ\r\n    def set_health(self, health, procents=1):\r\n        self.health = health\r\n        self.health_proc = procents\r\n        self.health_current = self.health_max * self.health_proc\r\n\r\n    # помещает предмет в руки ГГ и заменяет спрайт\r\n    def set_hands(self, item, sprite_path):\r\n        self.hands = item\r\n        self.image = load_image(sprite_path)\r\n    # -----------------------------------------------------------\r\n\r\n    # метод для создания объекта пули| args: позиция мыши в момент стрельбы\r\n    def fire(self, mouse_xy):\r\n        # создаем объект класса Bullet\r\n        \"\"\"его пока не существует)\"\"\"\r\n        pass\r\n\r\n\r\n# Класс объекта на игровом поле\r\nclass Object(pygame.sprite.Sprite):\r\n    def __init__(self):\r\n        super().__init__(all_sprites)\r\n\r\n        # Ширина и высота каждого объекта по умолчанию 20px\r\n        self.width = 20\r\n        self.height = 20\r\n\r\n        # По умолчанию у объектов нет изображения\r\n        self.image = None\r\n        if self.image is not None:\r\n            self.rect = self.image.get_rect()\r\n            self.rect.x = 0\r\n            self.rect.y = 0\r\n\r\n    # Функция для добавления объекта в группу спрайтов\r\n    def set_group(self, group):\r\n        if type(group) == pygame.sprite.Group:\r\n            self.add(group)\r\n            return True\r\n        return False\r\n\r\n    # Функция для изменения ширины и высоты объекта\r\n    def set_size(self, width, height):\r\n        try:\r\n            if width >= 0 and height >= 0:\r\n                self.width = width\r\n                self.height = height\r\n                return True\r\n            return False\r\n        except Exception:\r\n            return False\r\n\r\n    # Функция установки изображения объекту\r\n    def set_image(self, image_name):\r\n        if type(image_name) == str:\r\n            img = load_image(image_name)\r\n            if type(img) != bool:\r\n                self.image = img\r\n                self.rect = self.image.get_rect()\r\n                self.rect.x = 0\r\n                self.rect.y = 0\r\n                # self.mask = pygame.mask.from_surface(self.image)\r\n                return True\r\n        return False\r\n\r\n\r\n\"\"\" Далее идут отдельные классы для каждого определённого объекта,\r\nгде каждый наследуется от класса Object и задаёт параметры под себя\"\"\"\r\n\r\n\r\n# Классы для стен\r\nclass VWall(Object):\r\n    def __init__(self):\r\n        super().__init__()\r\n        self.set_group(barriers)\r\n        self.set_image('field/vertical_wall.png')\r\n        self.set_group(walls)\r\n\r\n\r\nclass HWall(Object):\r\n    def __init__(self):\r\n        super().__init__()\r\n        self.set_group(barriers)\r\n        self.set_image('field/horizontal_wall.png')\r\n        self.set_group(walls)\r\n\r\n\r\nclass WNWall(Object):\r\n    def __init__(self):\r\n        super().__init__()\r\n        self.set_group(barriers)\r\n        self.set_image('field/wn_wall.png')\r\n        self.set_group(walls)\r\n\r\n\r\nclass NEWall(Object):\r\n    def __init__(self):\r\n        super().__init__()\r\n        self.set_group(barriers)\r\n        self.set_image('field/ne_wall.png')\r\n        self.set_group(walls)\r\n\r\n\r\nclass ESWall(Object):\r\n    def __init__(self):\r\n        super().__init__()\r\n        self.set_group(barriers)\r\n        self.set_image('field/es_wall.png')\r\n        self.set_group(walls)\r\n\r\n\r\nclass SWWall(Object):\r\n    def __init__(self):\r\n        super().__init__()\r\n        self.set_group(barriers)\r\n        self.set_image('field/sw_wall.png')\r\n        self.set_group(walls)\r\n\r\n\r\nclass ESWWall(Object):\r\n    def __init__(self):\r\n        super().__init__()\r\n        self.set_group(barriers)\r\n        self.set_image('field/esw_wall.png')\r\n        self.set_group(walls)\r\n\r\n\r\nclass NESWall(Object):\r\n    def __init__(self):\r\n        super().__init__()\r\n        self.set_group(barriers)\r\n        self.set_image('field/nes_wall.png')\r\n        self.set_group(walls)\r\n\r\n\r\nclass SWNWall(Object):\r\n    def __init__(self):\r\n        super().__init__()\r\n        self.set_group(barriers)\r\n        self.set_image('field/swn_wall.png')\r\n        self.set_group(walls)\r\n\r\n\r\nclass WNEWall(Object):\r\n    def __init__(self):\r\n        super().__init__()\r\n        self.set_group(barriers)\r\n        self.set_image('field/wne_wall.png')\r\n        self.set_group(walls)\r\n\r\n\r\nclass NESWWall(Object):\r\n    def __init__(self):\r\n        super().__init__()\r\n        self.set_group(barriers)\r\n        self.set_image('field/nesw_wall.png')\r\n        self.set_group(walls)\r\n\r\n\r\nclass BPanel(Object):\r\n    def __init__(self):\r\n        super().__init__()\r\n        self.set_image('field/black_panel.png')\r\n        self.set_group(floor)\r\n\r\n\r\n# Классы для комнат\r\nclass WoodenRoom(Object):\r\n    def __init__(self):\r\n        super().__init__()\r\n        self.set_size(140, 140)\r\n        self.set_image('field/wooden_room.png')\r\n        self.set_group(rooms)\r\n\r\n\r\nclass StoneRoom(Object):\r\n    def __init__(self):\r\n        super().__init__()\r\n        self.set_size(180, 80)\r\n        self.set_image('field/stone_room.png')\r\n        self.set_group(rooms)\r\n\r\n\r\nclass ParquetRoom(Object):\r\n    def __init__(self):\r\n        super().__init__()\r\n        self.set_size(240, 340)\r\n        self.set_image('field/parquet_room.png')\r\n        self.set_group(rooms)\r\n\r\n\r\n# Классы для мебели\r\nclass Billiard(Object):\r\n    def __init__(self):\r\n        super().__init__()\r\n        self.set_group(barriers)\r\n        self.set_size(100, 61)\r\n        self.set_image('field/billiard.png')\r\n        self.set_group(furniture)\r\n\r\n\r\nclass Poker(Object):\r\n    def __init__(self):\r\n        super().__init__()\r\n        self.set_group(barriers)\r\n        self.set_size(152, 146)\r\n        self.set_image('field/poker_table.png')\r\n        self.set_group(furniture)\r\n\r\n\r\n# Класс игрового поля\r\nclass Field:\r\n    def __init__(self, file=None):\r\n        # По умолчанию размер одной клетки 20px\r\n        self.cell_size = 20\r\n\r\n        # Значиния, которые показывают от какого x и y начть отрисовку карты\r\n        # Далее эти значения могут использоваться для движения всей карты\r\n        self.startx, self.starty = 50, 50\r\n\r\n        # Матрица с объектами карты задаётся пока в ручную, в будущем сделаю загрузку из файла\r\n        # и заменю каждый отдельный класс с объектом на словать с параметрами.\r\n        if file is None:\r\n            self.board = [[WNWall(), HWall(),      HWall(),    HWall(), HWall(),  HWall(), HWall(), HWall(), NEWall(),  None,    WNWall(),  HWall(),       HWall(), HWall(), HWall(), HWall(), HWall(), HWall(), HWall(), HWall(), HWall(), HWall(), HWall(), NEWall()],\r\n                          [VWall(),  WoodenRoom(), None,       None,    None,     None,    None,    None,    VWall(),   None,    VWall(),   ParquetRoom(), None,    None,    None,    None,    None,    None,    None,    None,    None,    None,    None,    VWall()],\r\n                          [VWall(),  None,         None,       None,    None,     None,    None,    None,    VWall(),   None,    VWall(),   None,          None,    None,    None,    None,    None,    None,    None,    None,    None,    None,    None,    VWall()],\r\n                          [VWall(),  None,         Billiard(), None,    None,     None,    None,    None,    VWall(),   None,    VWall(),   None,          None,    None,    None,    None,    None,    None,    None,    None,    None,    None,    None,    VWall()],\r\n                          [VWall(),  None,         None,       None,    None,     None,    None,    None,    VWall(),   None,    VWall(),   None,          None,    None,    Poker(), None,    None,    None,    None,    None,    None,    None,    None,    VWall()],\r\n                          [VWall(),  None,         None,       None,    None,     None,    None,    None,    VWall(),   None,    VWall(),   None,          None,    None,    None,    None,    None,    None,    None,    None,    None,    None,    None,    VWall()],\r\n                          [VWall(),  None,         None,       None,    None,     None,    None,    None,    VWall(),   None,    VWall(),   None,          None,    None,    None,    None,    None,    None,    None,    None,    None,    None,    None,    VWall()],\r\n                          [VWall(),  None,         None,       None,    None,     None,    None,    None,    VWall(),   None,    VWall(),   None,          None,    None,    None,    None,    None,    None,    None,    None,    None,    None,    None,    VWall()],\r\n                          [NESWall(), HWall(),     HWall(),    HWall(), BPanel(), HWall(), HWall(), HWall(), WNEWall(), HWall(), SWNWall(), None,          None,    None,    None,    None,    None,    None,    None,    None,    None,    None,    None,    VWall()],\r\n                          [VWall(),  StoneRoom(),  None,       None,    None,     None,    None,    None,    None,      None,    VWall(),   None,          None,    None,    None,    None,    None,    None,    None,    None,    None,    None,    None,    VWall()],\r\n                          [VWall(),  None,         None,       None,    None,     None,    None,    None,    None,      None,    BPanel(),  None,          None,    None,    None,    None,    None,    None,    None,    None,    None,    None,    None,    VWall()],\r\n                          [VWall(),  None,         None,       None,    None,     None,    None,    None,    None,      None,    BPanel(),  None,          None,    None,    None,    None,    None,    None,    None,    None,    None,    None,    None,    VWall()],\r\n                          [VWall(),  None,         None,       None,    None,     None,    None,    None,    None,      None,    VWall(),   None,          None,    None,    None,    None,    None,    None,    None,    None,    None,    None,    None,    VWall()],\r\n                          [SWWall(), HWall(),      HWall(),    HWall(), HWall(),  HWall(), HWall(), HWall(), HWall(),   HWall(), SWNWall(), None,          None,    None,    None,    None,    None,    None,    None,    None,    None,    None,    None,    VWall()],\r\n                          [None,     None,         None,       None,    None,     None,    None,    None,    None,      None,    VWall(),   None,          None,    None,    None,    None,    None,    None,    None,    None,    None,    None,    None,    VWall()],\r\n                          [None,     None,         None,       None,    None,     None,    None,    None,    None,      None,    VWall(),   None,          None,    None,    None,    None,    None,    None,    None,    None,    None,    None,    None,    VWall()],\r\n                          [None,     None,         None,       None,    None,     None,    None,    None,    None,      None,    VWall(),   None,          None,    None,    None,    None,    None,    None,    None,    None,    None,    None,    None,    VWall()],\r\n                          [None,     None,         None,       None,    None,     None,    None,    None,    None,      None,    VWall(),   None,          None,    None,    None,    None,    None,    None,    None,    None,    None,    None,    None,    VWall()],\r\n                          [None,     None,         None,       None,    None,     None,    None,    None,    None,      None,    SWWall(),  HWall(),       HWall(), HWall(), HWall(), HWall(), HWall(), HWall(), HWall(), HWall(), HWall(), HWall(), HWall(), ESWall()]]\r\n        else:\r\n            pass\r\n\r\n        # Ширина и высота карты в количестве клеток\r\n        self.width = len(self.board[0])\r\n        self.height = len(self.board)\r\n\r\n    # Функция для получения клетки по её координатам\r\n    def get_cell(self, cell_x, cell_y):\r\n        try:\r\n            x = (cell_x - self.startx) // self.cell_size\r\n            y = (cell_y - self.starty) // self.cell_size\r\n            cell = self.board[y][x]\r\n            return cell\r\n        except Exception:\r\n            return False\r\n\r\n    # Функция для расположения всех объектов карты в нужном порядке.\r\n    # Она используется в главном игровом цикле, но после неё\r\n    # всё равно нужно использвать all_sprites.draw(screen)\r\n    def render(self, screen):\r\n        pixel_w = self.width * self.cell_size + self.startx\r\n        pixel_h = self.height * self.cell_size + self.starty\r\n        for y in range(self.starty, pixel_h, self.cell_size):\r\n            for x in range(self.startx, pixel_w, self.cell_size):\r\n                cell = self.get_cell(x, y)\r\n                if type(cell) == bool and cell is False:\r\n                    return False\r\n                if cell is not None:\r\n                    cell.rect.x = x\r\n                    cell.rect.y = y\r\n\r\n    # Функция движения карты, где value_px это значение\r\n    # на сколько за раз сдвигается карта в пикселях\r\n    def move(self, value_px):\r\n        # Условие на нажатие стрелки вверх\r\n        if pygame.key.get_pressed()[pygame.K_UP]:\r\n            # Сдвиг карты на value_px вниз\r\n            self.starty += value_px\r\n            self.render(screen)\r\n            # Условие, если герой касается какого-либо прямоугольника\r\n            if pygame.sprite.spritecollideany(hero, barriers) is not None:\r\n                # возвращение карты в исходное состояние\r\n                self.starty += -value_px\r\n\r\n        # Условие на нажатие стрелки вниз\r\n        if pygame.key.get_pressed()[pygame.K_DOWN]:\r\n            # Сдвиг карты на value_px вверх\r\n            self.starty -= value_px\r\n            self.render(screen)\r\n            # Условие, если герой касается какого-либо прямоугольника\r\n            if pygame.sprite.spritecollideany(hero, barriers) is not None:\r\n                # возвращение карты в исходное состояние\r\n                self.starty -= -value_px\r\n\r\n        # Условие на нажатие стрелки вправо\r\n        if pygame.key.get_pressed()[pygame.K_RIGHT]:\r\n            # Сдвиг карты на value_px влево\r\n            self.startx -= value_px\r\n            self.render(screen)\r\n            # Условие, если герой касается какого-либо прямоугольника\r\n            if pygame.sprite.spritecollideany(hero, barriers) is not None:\r\n                # возвращение карты в исходное состояние\r\n                self.startx -= -value_px\r\n\r\n        # Условие на нажатие стрелки влево\r\n        if pygame.key.get_pressed()[pygame.K_LEFT]:\r\n            # Сдвиг карты на value_px вправо\r\n            self.startx += value_px\r\n            self.render(screen)\r\n            # Условие, если герой касается какого-либо прямоугольника\r\n            if pygame.sprite.spritecollideany(hero, barriers) is not None:\r\n                # возвращение карты в исходное состояние\r\n                self.startx += -value_px\r\n\r\n\r\nif __name__ == '__main__':\r\n    # Создание окна\r\n    pygame.init()\r\n    size = width, height = 700, 600\r\n    pygame.display.set_caption('Игровое поле')\r\n    screen = pygame.display.set_mode(size)\r\n\r\n    # Группы со спрайтами\r\n    # К группе barriers относится всё, через что нельзя проходить\r\n    all_sprites = pygame.sprite.Group()\r\n    barriers = pygame.sprite.Group()\r\n    walls = pygame.sprite.Group()\r\n    rooms = pygame.sprite.Group()\r\n    floor = pygame.sprite.Group()\r\n    furniture = pygame.sprite.Group()\r\n\r\n    # Создание игрового поля\r\n    game = Field()\r\n\r\n    # Создание главного героя в центре экрана\r\n    hero_group = pygame.sprite.Group()\r\n    hero = Hero(all_sprites, hero_group)\r\n    hero.set_place(343, 293)\r\n\r\n    # Создание события, которое срабатывает 1 раз в милисекунду\r\n    MOVING = pygame.USEREVENT + 1\r\n    pygame.time.set_timer(MOVING, 1)\r\n    screen.fill(pygame.Color('white'))\r\n\r\n    running = True\r\n    while running:\r\n        for event in pygame.event.get():\r\n            # Условие, если прошлё время и вызвалось событие\r\n            if event.type == MOVING:\r\n                # Перемещение карты на 1 пиксель\r\n                game.move(1)\r\n                screen.fill(pygame.Color('white'))\r\n\r\n            if event.type == pygame.QUIT:\r\n                running = False\r\n\r\n        # Расположение объектов карты\r\n        game.render(screen)\r\n\r\n        # Отрисовка объектов карты\r\n        all_sprites.draw(screen)\r\n\r\n        pygame.display.flip()\r\n    pygame.quit()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- field_moving.py	(revision 2f783f32e9f940a5b85096f350cb7c0772efe887)
+++ field_moving.py	(date 1614169974319)
@@ -396,7 +396,7 @@
 
     # Создание события, которое срабатывает 1 раз в милисекунду
     MOVING = pygame.USEREVENT + 1
-    pygame.time.set_timer(MOVING, 1)
+    pygame.time.set_timer(MOVING, 10)
     screen.fill(pygame.Color('white'))
 
     running = True
